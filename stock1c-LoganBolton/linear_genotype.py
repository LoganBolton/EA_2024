
# linear_genotype.py

import copy
import random
from copy import deepcopy

class LinearGenotype():
    def __init__(self):
        self.fitness = None
        self.genes = None


    def random_initialization(self, shapes, bounds, **kwargs):
        # TODO: Initialize self.genes, using the input parameters.
        #       It should be an indexable data structure of length len(shapes),
        #       where each element is an indexable data structure of length 3.
        #       The first value of each element should be an integer within the
        #       half-open interval [bounds[0][0], bounds[0][1]). The second should be
        #       similar, within [bounds[1][0], bounds[1][1]). The third should be
        #       either 0, 1, 2, or 3. All values should be chosen uniform randomly.
        
        random_genes = []
        for _ in range(len(shapes)):
            # randomly assign the values of the position (x, y) and rotation (r)
            x = random.randint(bounds[0][0], bounds[0][1]-1)
            y = random.randint(bounds[1][0], bounds[1][1]-1)
            r = random.randint(0, 3)
            
            gene = [x, y, r]
            random_genes.append(gene)
            
        self.genes = random_genes 
        return


    def serialize(self):
        # TODO: Return a string representation of self.genes
        output = ""
        
        # Add every gene to a comma seperated string
        for gene in self.genes:
            if output != "":
                output += ", "
            output += str(gene)
        return output
    

    def deserialize(self, serialization):
        # TODO: Recreate self.genes from serialization,
        #       which is a string generated by your serialize method
        genes = []
        serialization = serialization.replace('[', "").replace(']', "")
        
        numbers = serialization.split(',')
        numbers = [num.strip() for num in numbers]
        
        i = 0
        while i < len(numbers) - 2:  # Ensure we have at least 3 numbers left
            gene1 = int(numbers[i])
            gene2 = int(numbers[i+1])
            gene3 = int(numbers[i+2])
            genes.append([gene1, gene2, gene3])
            i += 3
        
        self.genes = genes


    def recombine(self, mate, method, **kwargs):
        child = LinearGenotype()

        # TODO: Recombine genes of self with mate and
        #       assign to child's genes member variable
        assert method.casefold() in {'uniform', 'one-point', 'bonus'}

        child.genes = []
        parent1 = self.genes
        parent2 = mate.genes
        parents = [parent1, parent2]

        if method.casefold() == 'uniform':
            # 50/50 chance of replacement
            for i in range(len(self.genes)):
                parent_choice = random.randint(0, 1)
                parent = parents[parent_choice] 
                
                new_gene = copy.deepcopy(parent[i])
                child.genes.append(new_gene)
            return child

        elif method.casefold() == 'one-point':
            # Perform one-point crossover
            point = random.randint(1, len(self.genes)-1)
            
            # First half of the genes
            for i in range(0, point):
                new_gene = copy.deepcopy(parent1[i])
                child.genes.append(new_gene)

            # Second half of the genes
            for i in range(point, len(self.genes)):
                new_gene = copy.deepcopy(parent2[i])
                child.genes.append(new_gene)
            
            return child

        elif method.casefold() == 'bonus':
            # This is a red deliverable (i.e., bonus for anyone).
            # Implement the bonus crossover operator as described
            # in deliverable Red 1 of Assignment 1b.
            pass

        return child


    def mutate(self, bounds, bonus=None, **kwargs):
        mutant = LinearGenotype()
        mutant.genes = deepcopy(self.genes)

        if not bonus:
            # TODO: Mutate genes of mutant
            for gene in mutant.genes:
                chosen_gene = random.randint(0, 2)
                
                new_x = random.randint(0, 49)
                new_y = random.randint(0, 14)
                new_r = random.randint(0, 3)
                
                if chosen_gene == 0:
                    gene[0] = new_x
                elif chosen_gene == 1:
                    gene[1] = new_y
                elif chosen_gene == 2:
                    gene[2] = new_r
            
            return mutant

        else:
            # This is a red deliverable (i.e., bonus for anyone).
            # Implement the bonus mutation operator as described
            # in deliverable Red 1 of Assignment 1b.
            pass

        return mutant


    @classmethod
    def initialization(cls, mu, *args, **kwargs):
        population = [cls() for _ in range(mu)]
        for i in range(len(population)):
            population[i].random_initialization(*args, **kwargs)
        return population
